// Pre-configured device memory state and pre-provisioned key store access
// management. 1. Fully specified configuration zone. 2. One permanent primary
// P-256 Elliptic Curve Cryptography (ECC) private key fixed at the first object
// creation. 3. One internal sign private key for key attestation. 4. Three
// secondary P-256 ECC private keys that can be regenerated by the user. 5.
// Signer public key from signer certificate. 6. ECDH/KDF key slot capable of
// being used with AES keys and commands. 7. X.509 Compressed Certificate
// Storage.
use super::client::AtCaClient;
use super::command::ClockDivider;
use super::error::Error;
use super::memory::{Slot, Zone};
use core::convert::TryFrom;
use core::fmt::Debug;
use embedded_hal::blocking::delay::DelayUs;
use embedded_hal::blocking::i2c::{Read, Write};

pub const AUTH_PRIVATE_KEY: Slot = Slot::PrivateKey00;
pub const SIGN_PRIVATE_KEY: Slot = Slot::PrivateKey01;
pub const USER_PRIVATE_KEY1: Slot = Slot::PrivateKey02;
pub const USER_PRIVATE_KEY2: Slot = Slot::PrivateKey03;
pub const USER_PRIVATE_KEY3: Slot = Slot::PrivateKey04;
pub const AES_KEY: Slot = Slot::Certificate09;

// Miscellaneous device states.
//
// TODO: Diff factory default and TNGTLS for each item in config zone bit by
// bit. Declare the differences below as a set of local constants.
#[allow(dead_code)]
pub(crate) const CLOCK_DIVIDER: ClockDivider = ClockDivider::Zero;

pub struct TrustAndGo<'a, PHY, D> {
    #[allow(dead_code)]
    atca: &'a mut AtCaClient<PHY, D>,
}

// On creation of TNG object, enforce stateful configuration.
impl<'a, PHY, D> TryFrom<&'a mut AtCaClient<PHY, D>> for TrustAndGo<'a, PHY, D>
where
    PHY: Read + Write,
    <PHY as Read>::Error: Debug,
    <PHY as Write>::Error: Debug,
    D: DelayUs<u32>,
{
    type Error = Error;
    fn try_from(atca: &'a mut AtCaClient<PHY, D>) -> Result<Self, Self::Error> {
        // Check if configuration zone is locked.
        if !atca.memory().is_locked(Zone::Config)? {
            // ChipMode
            // atca.memory().write_a()?;
            // atca.memory().write_b()?;
            // atca.memory().write_c()?;
            // atca.memory().write_d()?;
            atca.memory().lock(Zone::Config)?;
        }

        // Check if data zone is locked.
        if !atca.memory().is_locked(Zone::Data)? {
            // atca.memory().write_e()?;
            // atca.memory().write_f()?;
            // atca.memory().write_g()?;
            // atca.memory().write_h()?;
            atca.memory().lock(Zone::Data)?;
        }

        // Slot config
        // Key config
        Ok(Self { atca })
    }
}

impl<'a, PHY, D> TrustAndGo<'a, PHY, D>
where
    PHY: Read + Write,
    <PHY as Read>::Error: Debug,
    <PHY as Write>::Error: Debug,
    D: DelayUs<u32>,
{
    // Any support for ECDSA-WITH-SHA256?
}
